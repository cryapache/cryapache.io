[{"content":"进程与线程\r进程\r一个在内存中运行的应用程序。每个进程都有自己独立的一块内存空间，一个进程可以有多个线程，比如在Windows系统中，一个运行的xx.exe就是一个进程。\n线程\r线程是进程中的一个执行单元，负责当前进程中程序的执行，一个进程中至少有一个线程。一个进程中的多个线程共享进程中的全部资源。\n区别\r进程是资源分配的基本单位，线程是CPU调度的基本单位。 进程有自己独立的地址空间，每启动一个进程，系统就会为它分配地址空间，建立数据表来维护代码段、堆栈段和数据段，线程没有独立的地址空间，它使用相同的地址空间共享数据。 多线程的优点\r提高CPU利用率\n多线程可以充分利用多核处理器的能力，使不同的线程在不同的核心上并行运行，从而提高了CPU的利用率。 响应性\n对于需要保持用户界面响应的应用（如图形用户界面应用程序），多线程可以让一部分线程处理用户输入，而其他线程进行后台计算或其他任务，这样可以确保应用程序对用户的操作及时作出反应。 简化程序结构\n通过将复杂任务分解成更小、更易于管理的线程，可以简化程序的设计和实现。 资源共享\n同一进程内的所有线程共享内存空间和其他资源，这使得线程之间的通信和数据交换变得简单高效。 Java多线程\rjava实现多线程的原理\r多线程通过java中的java.long.Thread类来体现\n通过Thread子类的run方法来执行线程的任务，通过调用Thread子类的start方法来启动线程\n在 java 中，每次程序运行至少启动 2 个线程。个是 main 线程，一个是垃圾收集线程。\n创建java线程\r通过继承Thread类创建线程\r//创建继承Thread类的子类 public class ThreadTest extends Thread{ @Override public void run() { //线程任务 } } //使用start方法启动线程 public class Main{ public static void main(String[] args) { ThreadTest threadTest = new ThreadTest(); threadTest.start(); } } run方法不会启动线程，不会分配新的分支栈 start方法可以用于启动一个分支线程，启动成功的线程会自动调用run方法，实现其中的线程任务 start方法调用后并非立即执行多线程代码，而是使其变为可执行态，具体执行时间由操作系统决定 多线程程序乱序执行，执行顺序随机 start方法重复调用会出现java.lang.lllegaIThreadStateException异常 thread类常用方法\rstart()：启动线程，调用线程的run方法 run()：线程执行体，用于定义线程的任务 currentThread()：静态方法，返回对当前正在执行的线程对象的引用 getName()：获取当前线程的名字 setName()：设置当前线程的名字 yield()：释放当前CPU的执行权 join()：等待该线程终止 isAlive()：判断当前线程是否存活 sleep(long millis)：让当前线程“睡眠”millis毫秒 setPriority(int newPriority)：设置线程的优先级 getPriority()：获取线程的优先级 setDaemon(boolean on)：将该线程标记为守护线程或用户线程 isDaemon()：判断该线程是否为守护线程 stop()：强制停止线程（已废弃） 通过实现Runnable接口创建线程\r//创建实现Runnable接口的类 public class ThreadTest implements Runnable{ @Override public void run() { //线程任务 } } //使用Thread类来启动线程 public class Main{ public static void main(String[] args) { ThreadTest threadTest = new ThreadTest();//创建实现Runnable接口的类的对象 Thread thread = new Thread(threadTest);//创建Thread类对象，并将实现Runnable接口的类的对象作为参数传入 thread.start();//启动线程 } } 比起继承Thread类实现多线程的好处\r避免了Java单继承的局限性 适合多个相同程序的代码去处理同一个资源的情况，把线程同程序的代码、数据有效分离，较好的体现了面向对象的思想 线程池只能放进实现Runnable或Callable类线程，不能放进继承Thread类创建的线程 线程的生命周期\r新建 (New)\n新建一个线程对象，调用start()方法之前，线程处于新建状态。。 就绪 (Runnable)\n当start()方法被调用后，线程进入就绪状态。此时线程位于可运行的线程池中，等待获取cpu使用权 运行 (Running)\n就绪状态的线程获取cpu资源，开始执行代码 阻塞 (Blocked)\n线程因某种原因放弃cpu资源，暂时停止运行。等待线程进入就绪状态后才有机会进入运行状态 死亡 (Dead)\n线程执行完毕或因异常退出run()方法，线程结束生命周期 阻塞\r阻塞的情况分为三种：\n等待阻塞：运行中的线程执行wait()方法，JVM会把该线程放入等待池中。（wait方法会释放持有的锁） 同步阻塞：运行中的线程执行同步方法，锁被其他线程占用，JVM会把该线程放入锁池中。 其他阻塞：运行中的线程执行sleep()或join()方法，或者发出了I/O请求时，JVM会把该线程置为阻塞状态。当sleep()状态超时、join()等待线程终止或者超时、或者I/O处理完毕时，线程重新转入就绪状态。(sleep不会释放持有的锁) 线程调度\r线程优先级\rJava中的线程优先级范围从MAX_PRIORITY = 1到MIN_PRIORITY = 10，默认为NORM_PRIORITY = 5。 线程优先级高的线程分配CPU时间片的概率会更高，但不代表一定优先执行。 使用setPriority()和getPriority()方法可以设置和获取线程的优先级。 线程睡眠、等待与唤醒\rThread.sleep(long millis)让线程进入休眠（阻塞状态）放弃占有cpu时间片，让给其他线程使用(不释放锁) sleep方法可以做到间隔特定的时间去执行代码，每隔多久执行一次 wait()方法让线程无限期等待(释放当前线程的锁) notify()方法唤醒一个正在等待的线程(不释放当前线程的锁) notifyAll()唤醒此对象监视器上所有等待的线程 线程礼让\rThread.yield()让当前线程让出cpu时间片，与其他线程一起重新竞争cpu时间片 yield方法不会阻塞线程，只是让线程从运行状态转为就绪状态，让cpu重新调度线程 sleep阻塞的时间是固定的，而yield方法让出的时间无法设定\n线程加入\rjoin()让一个线程等待另一个线程执行完毕后再继续执行 join()方法要再start()方法调用后才能生效 线程同步\r多个线程对同一个内存地址进行写入时，由于cpu时间调度上的问题，写入数据会被多次覆盖，可能会导致数据不一致或未定义行为。 因此需要通过同步机制确保同一时间只有一个线程能进行修改操作，以维护数据的一致性和完整性。\n线程同步的同是指协同运作而非同时运作\n互斥锁\r如果对一个变量加上互斥锁，那么在同一时刻，该变量只能有一个线程能访问，即当一个线程访问临界资源时，其他线程只能等待。 在 Java 中，每一个对象都有一个锁标记（ monitor ），也被称为监视器，当多个线程访问对象时，只有获取了对象的锁才能访问。 使用synchronized实现同步互斥访问\rsynchornized代码块方式 public void myThread1(Thread thread) { synchronized (this) { for (int i = 0; i \u0026lt; 5; i++) { System.out.println(thread.getName() + \u0026#34;:\u0026#34; + i); } } } 此方法中synchronized修饰一个代码块，锁定当前对象实例\n在实例方法中使用synchornized public synchronized void myThread2(Thread thread) { for (int i = 0; i \u0026lt; 5; i++) { System.out.println(thread.getName() + \u0026#34;:\u0026#34; + i); } } 在此方法中synchronized修饰整个方法，锁定当前对象实例\n在静态方法中使用synchornized public static synchronized void myThread3(Thread thread) { for (int i = 0; i \u0026lt; 5; i++) { System.out.println(thread.getName() + \u0026#34;:\u0026#34; + i); } } 在此方法中synchronized修饰整个方法，锁定类本身，\n如果一个方法或者代码块被 synchronized 关键字修饰，当线程获取到该方法或代码块的锁，其他线程是不能继续访问该方法或代码块的。而其他线程想访问该方法或代码块，就必须要等待获取到锁的线程释放这个锁。在这里，释放锁只有两种情况：\n线程执行完代码块：线程完成同步代码块或方法中的所有指令后，会自动释放锁。 程序报错：如果在执行过程中遇到未处理的异常，JVM 会让线程自动释放它所持有的锁。 ","date":"2024-12-09T22:41:54+08:00","permalink":"http://localhost:1313/post/java-%E5%A4%9A%E7%BA%BF%E7%A8%8B/","title":"Java 多线程"},{"content":"Lingo主要作用\r快速求解线性规划、非线性规划、线性和非线性方程组等\n简单线性问题求解\r这样的题目直接复述即可\n结果如下\n语法\r基本用法\u0026amp;一些小点\rlingo中数学规划模型包含目标函数、决策变量、约束条件三个要素 lingo中每一句都要用英文分号结束 以英文!开始注释，需要以英文分号结束 变量不区分字母大小写，要求以字母开头，后面可以有数字与下划线，不超过32个字符 定义好集合后的语句顺序是随意的 函数以@开头 LINGO中各变量默认是非负的 偶尔莫名其妙出现的model报错，重启lingo后又没有了 集合\r集合部分的语法为\nsets:\n集合名称1/成员列表1/：属性1_1，属性1_2，…，属性1_n1；\n集合名称2/成员列表2/：属性2_1，属性2_2，…，属性2_n2；\n派生集合名称（集合名称1，集合名称2）：属性3_1，…，属性3_n3；\nendsets\neg:\nSETS:\rPRODUCTS /Prod1, Prod2, Prod3/: Profit;\rMACHINES /Mach1, Mach2, Mach3/: TimeAvailable;\rLINKS(PRODUCTS, MACHINES): TimeRequired;\rENDSETS 数据\r数据部分的语法为\ndata:\n属性1 = 数据列表;\n属性2 = 数据列表;\nenddata\neg:\nDATA:\rProfit = 300, 500, 200;\rTimeAvailable = 40, 60, 50;\rTimeRequired = 1.5, 2.0, 1.0,\r1.0, 1.5, 2.0,\r2.0, 1.0, 1.5;\rENDDATA 函数\r算术运算符\r加减乘除乘方分别为+ - * / ^\n逻辑运算符\r#not# 否定该操作数的逻辑值，＃not＃是一个一元运算符。\n#eq# 若两个运算数相等，则为 true；否则为 false。\n#ne# 若两个运算符不相等，则为 true；否则为 false。\n#gt# 若左边的运算符严格大于右边的运算符，则为 true；否则为 false。\n#ge# 若左边的运算符大于或等于右边的运算符，则为 true；否则为 false。\n#lt# 若左边的运算符严格小于右边的运算符，则为 true；否则为 false。\n#le# 若左边的运算符小于或等于右边的运算符，则为 true；否则为 false。\n#and# 仅当两个参数都为 true 时，结果为 true；否则为 false。\n#or# 仅当两个参数都为 false 时，结果为 false；否则为 true。\n常见数学函数\r@abs(x)返回 x 的绝对值。\n@sin(x)返回 x 的正弦值，x 采用弧度制。\n@cos(x)返回 x 的余弦值。\n@tan(x)返回 x 的正切值。\n@exp(x)返回常数 e 的 x 次方。\n@log(x)返回 x 的自然对数。\n@lgm(x)返回 x 的 gamma 函数的自然对数。\n@mod(x,y)返回 x 除以 y 的余数。\n@sign(x)如果 x0 时返回 1，当 x=0 时返回 0。\n@floor(x)返回 x 的整数部分。当 x\u0026gt;=0 时，返回不超过 x 的最大整数；当 x\u0026lt;0 时，返回 不低于 x 的最大整数。\n@smax(x1,x2,…,xn)返回 x1，x2，…，xn 中的最大值。\n@smin(x1,x2,…,xn)返回 x1，x2，…，xn 中的最小值。\n变量界定函数\r变量界定函数实现对变量取值范围的附加限制，共 4 种\n@bin(x)限制 x 为 0 或 1；\n@bnd(L,x,U)限制 L≤x≤U；\n@free(x)取消对变量 x 的默认下界为 0 的限制，即 x 可以取任意实数；\n@gin(x)限制 x 为整数。\n在默认情况下，LINGO 规定变量是非负的，也就是说下界为 0，上界为+∞。@free 取 消了默认的下界为 0 的限制，使变量也可以取负值。@bnd 用于设定一个变量的上下界,也可以取消默认下界为 0 的约束。\r级循环函数\r@for：该函数用来产生对集成员的约束。\n@sum：该函数返回遍历指定的集成员的一个表达式的和。\n@min 和@max：返回指定的集成员的一个表达式的最小值或最大值。\n","date":"2024-12-05T17:04:52+08:00","permalink":"http://localhost:1313/post/lingo%E4%BD%BF%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%AC%94%E8%AE%B0/","title":"Lingo使用的一些笔记"},{"content":"前言\r搭个博客各种问题改来改去好麻烦，简单记录一下做到目前这个程度的路径吧。\n使用Hugo本地建站\r什么是Hugo\rHugo是由 Go 语言实现的静态网站生成器。简单、易用、高效、易扩展、快速部署。\n下面内容参考hugo官网的quick start\nHugo本地安装\r可以参考官方文档,我是win11系统，这里使用Chocolatey安装了hugo的拓展版本:\nchoco install hugo-extended Chocolatey 是一个流行的软件包管理器，主要用于 Windows 操作系统。它受到 Linux 和 Mac 系统中已有的包管理工具（如 apt、yum 和 Homebrew）的启发，旨在简化在 Windows 平台上安装和更新软件的过程。这个可以自行学习使用。\n安装完成后，输入以下命令检查hugo版本：\nhugo version 使用hugo创建博客\r输入下列指令以创建博客项目：\nhugo new site [项目名称] 该命令会在目录下创建博客项目文件夹，输入指令将其该为当前根目录\ncd [项目名称] 这里我是用的主题是stack，将其克隆到themes文件夹\ngit submodule add https://github.com/CaiJimmy/hugo-theme-stack/ themes/hugo-theme-stack 在网站配置文件夹hugo.toml文件后追加一行，指向当前主题\ntheme = \u0026#39;主题文件夹名称\u0026#39; 启动Hugo的开发服务器查看站点\nhugo server 如果运行成功，提示的倒数第二行会显示本地服务器地址，打开即可看到你部署的网页。\n按Ctrl + C停止运行\nStack主题美化\rStack是hugo中的一个主题，详细配置可以参考Stack中文文档\n编写博客\r使用hugo创建文章\r在博客根目录下运行创建新博客文章:\nhugo new post/untitled.md 比起直接新建.md文件，使用hugo创建可以自动填充Front Matter模板，模板可以在\\archetypes\\default.md中找到并修改\n添加图片\r众所周知.md文件是不存储图片的，想在文章中存储图片有三种方式:\n一种是将图片添加到静态资源中然后引用，这样编译后图片会存储在网站根目录以供调用，缺点是编写时没法查看图片，全凭感觉。\n还可以在创建博客时多建一层，使文件夹结构如下\npost newBlog index.md img.png 这样则可以通过相对路径调用图片\n还有就是通过图床来调用，这个可以稍后再学\n","date":"2024-08-06T19:39:48+08:00","image":"http://localhost:1313/post/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/cover_hu3709778294414975464.png","permalink":"http://localhost:1313/post/%E4%BD%BF%E7%94%A8hugo%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/","title":"使用hugo搭建博客"}]